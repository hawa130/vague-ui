// @sts-nocheck
import { existsSync, promises as fs } from 'fs'
import { tmpdir } from 'os'
import path from 'path'

import template from 'lodash.template'
import { rimraf } from 'rimraf'
import { Project, ScriptKind } from 'ts-morph'
import { z } from 'zod'

import { registry } from '@/registry'
import { baseColors } from '@/registry/registry-base-colors'
import { colorMapping, colors } from '@/registry/registry-colors'
import { styles } from '@/registry/registry-styles'
import {
  Registry,
  RegistryEntry,
  registryEntrySchema,
  registryItemTypeSchema,
  registrySchema,
} from '@/registry/schema'

const REGISTRY_PATH = path.join(process.cwd(), 'public/registry')

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  'registry:ui',
  'registry:lib',
  'registry:hook',
  'registry:theme',
]

const project = new Project({
  compilerOptions: {},
})

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), 'vague-'))
  return path.join(dir, filename)
}

// ----------------------------------------------------------------------------
// Build registry-index/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from 'react'

export const Index: Record<string, any> = {
`

  for (const style of styles) {
    index += `  '${style.name}': {`

    // Build style index.
    for (const item of registry) {
      const resolveFiles = item.files?.map(
        (file) => `registry/${style.name}/${typeof file === 'string' ? file : file.path}`,
      )
      if (!resolveFiles) {
        continue
      }

      const type = item.type.split(':')[1]
      let sourceFilename = ''

      let chunks: any = []

      let componentPath = `@/registry/${style.name}/${type}/${item.name}`

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === 'string' ? { type: 'registry:page', path: file } : file,
        )
        if (files?.length) {
          componentPath = `@/registry/${style.name}/${files[0].path}`
        }
      }

      index += `
    '${item.name}': {
      name: '${item.name}',
      description: '${item.description ?? ''}',
      type: '${item.type}',
      registryDependencies: ${item.registryDependencies ? `[${item.registryDependencies.map((dep) => `'${dep}'`)}]` : '[]'},
      files: [${resolveFiles.map((file) => `'${file}'`)}],
      component: React.lazy(() => import('${componentPath}')),
      source: '${sourceFilename}',
      category: '${item.category ?? ''}',
      subcategory: '${item.subcategory ?? ''}',
      chunks: [${chunks.map(
        (chunk: any) => `{
        name: '${chunk.name}',
        description: '${chunk.description ?? 'No description'}',
        component: ${chunk.component}
        file: '${chunk.file}',
        container: {
          className: '${chunk.container.className}'
        }
      }`,
      )}]
    },`
    }

    index += `
  },`
  }

  index += `
}
`

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry
    .filter((item) => ['registry:ui'].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === 'string'
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file

          return file
        }),
      }
    })
  const registryJson = JSON.stringify(items, null, 2)
  rimraf.sync(path.join(REGISTRY_PATH, 'index.json'))
  await fs.writeFile(path.join(REGISTRY_PATH, 'index.json'), registryJson, 'utf8')

  // Write style index.
  rimraf.sync(path.join(process.cwd(), 'registry-index/index.tsx'))
  await fs.writeFile(path.join(process.cwd(), 'registry-index/index.tsx'), index)
}

// ----------------------------------------------------------------------------
// Build registry/styles/[style]/[name].json.
// ----------------------------------------------------------------------------
async function buildStyles(registry: Registry) {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, 'styles', style.name)

    // Create directory if it doesn't exist.
    if (!existsSync(targetPath)) {
      await fs.mkdir(targetPath, { recursive: true })
    }

    for (const item of registry) {
      if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
        continue
      }

      let files
      if (item.files) {
        files = await Promise.all(
          item.files.map(async (_file) => {
            const file =
              typeof _file === 'string'
                ? {
                    path: _file,
                    type: item.type,
                    content: '',
                    target: '',
                  }
                : _file

            let content: string
            try {
              content = await fs.readFile(
                path.join(process.cwd(), 'registry', style.name, file.path),
                'utf8',
              )
            } catch (error) {
              return
            }

            const tempFile = await createTempSourceFile(file.path)
            const sourceFile = project.createSourceFile(tempFile, content, {
              scriptKind: ScriptKind.TSX,
            })

            sourceFile.getVariableDeclaration('iframeHeight')?.remove()
            sourceFile.getVariableDeclaration('containerClassName')?.remove()
            sourceFile.getVariableDeclaration('description')?.remove()

            let target = file.target

            return {
              path: file.path,
              type: file.type,
              content: sourceFile.getText(),
              target,
            }
          }),
        )
      }

      const payload = registryEntrySchema
        .omit({
          source: true,
          category: true,
          subcategory: true,
          chunks: true,
        })
        .safeParse({
          ...item,
          files,
        })

      if (payload.success) {
        await fs.writeFile(
          path.join(targetPath, `${item.name}.json`),
          JSON.stringify(payload.data, null, 2),
          'utf8',
        )
      }
    }
  }

  // ----------------------------------------------------------------------------
  // Build registry/styles/index.json.
  // ----------------------------------------------------------------------------
  const stylesJson = JSON.stringify(styles, null, 2)
  await fs.writeFile(path.join(REGISTRY_PATH, 'styles/index.json'), stylesJson, 'utf8')
}

// ----------------------------------------------------------------------------
// Build registry/styles/[name]/index.json.
// ----------------------------------------------------------------------------
async function buildStylesIndex() {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, 'styles', style.name)

    const dependencies = ['tailwindcss-animate', 'tailwindcss-radix-colors', 'class-variance-authority', 'lucide-react']

    const payload: RegistryEntry = {
      name: style.name,
      type: 'registry:style',
      dependencies,
      registryDependencies: ['utils', 'tailwindcss-join'],
      tailwind: {
        config: {
          plugins: [
            `require('tailwindcss-animate')`,
            `require('tailwindcss-radix-colors')`,
            `require('./lib/tailwindcss-join')`,
          ],
        },
      },
      cssVars: {},
      files: [],
    }

    await fs.writeFile(
      path.join(targetPath, 'index.json'),
      JSON.stringify(payload, null, 2),
      'utf8',
    )
  }
}

// ----------------------------------------------------------------------------
// Build registry/colors/index.json.
// ----------------------------------------------------------------------------
async function buildThemes() {
  const colorsTargetPath = path.join(REGISTRY_PATH, 'colors')
  rimraf.sync(colorsTargetPath)
  if (!existsSync(colorsTargetPath)) {
    await fs.mkdir(colorsTargetPath, { recursive: true })
  }

  const colorsData: Record<string, any> = {}
  for (const [color, value] of Object.entries(colors)) {
    if (typeof value === 'string') {
      colorsData[color] = value
      continue
    }

    if (Array.isArray(value)) {
      colorsData[color] = value.map((item) => ({
        ...item,
        rgbChannel: item.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, '$1 $2 $3'),
        hslChannel: item.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, '$1 $2 $3'),
      }))
      continue
    }

    if (typeof value === 'object') {
      colorsData[color] = {
        ...value,
        rgbChannel: value.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, '$1 $2 $3'),
        hslChannel: value.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, '$1 $2 $3'),
      }
      continue
    }
  }

  await fs.writeFile(
    path.join(colorsTargetPath, 'index.json'),
    JSON.stringify(colorsData, null, 2),
    'utf8',
  )

  // ----------------------------------------------------------------------------
  // Build registry/colors/[base].json.
  // ----------------------------------------------------------------------------
  const BASE_STYLES = `@tailwind base;
@tailwind components;
@tailwind utilities;
  `

  const BASE_STYLES_WITH_VARIABLES = `@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: <%- colors.light.background %>;
    --foreground: <%- colors.light.foreground %>;
    --fg-invert: <%- colors.light['fg-invert'] %>;

    --card: <%- colors.light.card %>;
    --card-fg: <%- colors.light['card-fg'] %>;

    --popover: <%- colors.light.popover %>;
    --popover-fg: <%- colors.light['popover-fg'] %>;

    --secondary: <%- colors.light.secondary %>;
    --secondary-fg: <%- colors.light['secondary-fg'] %>;

    --muted: <%- colors.light.muted %>;
    --muted-fg: <%- colors.light['muted-fg'] %>;

    --segment: <%- colors.light.segment %>;
    --segment-fg: <%- colors.light['segment-fg'] %>;
    --segment-active: <%- colors.light['segment-active'] %>;
    --segment-active-fg: <%- colors.light['segment-active-fg'] %>;

    --accent: <%- colors.light.accent %>;
    --accent-dark: <%- colors.light['accent-dark'] %>;
    --accent-fg: <%- colors.light['accent-fg'] %>;

    --primary-1: <%- colors.light['primary-1'] %>;
    --primary-2: <%- colors.light['primary-2'] %>;
    --primary-3: <%- colors.light['primary-3'] %>;
    --primary: <%- colors.light.primary %>;
    --primary-5: <%- colors.light['primary-5'] %>;
    --primary-6: <%- colors.light['primary-6'] %>;

    --destructive-1: <%- colors.light['destructive-1'] %>;
    --destructive-2: <%- colors.light['destructive-2'] %>;
    --destructive-3: <%- colors.light['destructive-3'] %>;
    --destructive: <%- colors.light.destructive %>;
    --destructive-5: <%- colors.light['destructive-5'] %>;
    --destructive-6: <%- colors.light['destructive-6'] %>;

    --warning-1: <%- colors.light['warning-1'] %>;
    --warning-2: <%- colors.light['warning-2'] %>;
    --warning-3: <%- colors.light['warning-3'] %>;
    --warning: <%- colors.light.warning %>;
    --warning-5: <%- colors.light['warning-5'] %>;
    --warning-6: <%- colors.light['warning-6'] %>;

    --success-1: <%- colors.light['success-1'] %>;
    --success-2: <%- colors.light['success-2'] %>;
    --success-3: <%- colors.light['success-3'] %>;
    --success: <%- colors.light.success %>;
    --success-5: <%- colors.light['success-5'] %>;
    --success-6: <%- colors.light['success-6'] %>;

    --info-1: <%- colors.light['info-1'] %>;
    --info-2: <%- colors.light['info-2'] %>;
    --info-3: <%- colors.light['info-3'] %>;
    --info: <%- colors.light.info %>;
    --info-5: <%- colors.light['info-5'] %>;
    --info-6: <%- colors.light['info-6'] %>;

    --body: <%- colors.light.body %>;
    --button: <%- colors.light.button %>;
    --border: <%- colors.light.border %>;
    --input: <%- colors.light.input %>;

    --ring-accent: <%- colors.light['ring-accent'] %>;
    --ring-focus: <%- colors.light['ring-focus'] %>;
    
    --radius: 0.5rem;

    --chart-1: <%- colors.light['chart-1'] %>;
    --chart-2: <%- colors.light['chart-2'] %>;
    --chart-3: <%- colors.light['chart-3'] %>;
    --chart-4: <%- colors.light['chart-4'] %>;
    --chart-5: <%- colors.light['chart-5'] %>;
  }

  .dark {
    --background: <%- colors.dark.background %>;
    --foreground: <%- colors.dark.foreground %>;
    --fg-invert: <%- colors.dark['fg-invert'] %>;

    --card: <%- colors.dark.card %>;
    --card-fg: <%- colors.dark['card-fg'] %>;

    --popover: <%- colors.dark.popover %>;
    --popover-fg: <%- colors.dark['popover-fg'] %>;

    --secondary: <%- colors.dark.secondary %>;
    --secondary-fg: <%- colors.dark['secondary-fg'] %>;

    --muted: <%- colors.dark.muted %>;
    --muted-fg: <%- colors.dark['muted-fg'] %>;

    --segment: <%- colors.dark.segment %>;
    --segment-fg: <%- colors.dark['segment-fg'] %>;
    --segment-active: <%- colors.dark['segment-active'] %>;
    --segment-active-fg: <%- colors.dark['segment-active-fg'] %>;

    --accent: <%- colors.dark.accent %>;
    --accent-dark: <%- colors.dark['accent-dark'] %>;
    --accent-fg: <%- colors.dark['accent-fg'] %>;

    --primary-1: <%- colors.dark['primary-1'] %>;
    --primary-2: <%- colors.dark['primary-2'] %>;
    --primary-3: <%- colors.dark['primary-3'] %>;
    --primary: <%- colors.dark.primary %>;
    --primary-5: <%- colors.dark['primary-5'] %>;
    --primary-6: <%- colors.dark['primary-6'] %>;

    --destructive-1: <%- colors.dark['destructive-1'] %>;
    --destructive-2: <%- colors.dark['destructive-2'] %>;
    --destructive-3: <%- colors.dark['destructive-3'] %>;
    --destructive: <%- colors.dark.destructive %>;
    --destructive-5: <%- colors.dark['destructive-5'] %>;
    --destructive-6: <%- colors.dark['destructive-6'] %>;

    --warning-1: <%- colors.dark['warning-1'] %>;
    --warning-2: <%- colors.dark['warning-2'] %>;
    --warning-3: <%- colors.dark['warning-3'] %>;
    --warning: <%- colors.dark.warning %>;
    --warning-5: <%- colors.dark['warning-5'] %>;
    --warning-6: <%- colors.dark['warning-6'] %>;

    --success-1: <%- colors.dark['success-1'] %>;
    --success-2: <%- colors.dark['success-2'] %>;
    --success-3: <%- colors.dark['success-3'] %>;
    --success: <%- colors.dark.success %>;
    --success-5: <%- colors.dark['success-5'] %>;
    --success-6: <%- colors.dark['success-6'] %>;

    --info-1: <%- colors.dark['info-1'] %>;
    --info-2: <%- colors.dark['info-2'] %>;
    --info-3: <%- colors.dark['info-3'] %>;
    --info: <%- colors.dark.info %>;
    --info-5: <%- colors.dark['info-5'] %>;
    --info-6: <%- colors.dark['info-6'] %>;

    --body: <%- colors.dark.body %>;
    --button: <%- colors.dark.button %>;
    --border: <%- colors.dark.border %>;
    --input: <%- colors.dark.input %>;

    --ring-accent: <%- colors.dark['ring-accent'] %>;
    --ring-focus: <%- colors.dark['ring-focus'] %>;

    --chart-1: <%- colors.dark['chart-1'] %>;
    --chart-2: <%- colors.dark['chart-2'] %>;
    --chart-3: <%- colors.dark['chart-3'] %>;
    --chart-4: <%- colors.dark['chart-4'] %>;
    --chart-5: <%- colors.dark['chart-5'] %>;
  }
}

@layer base {
  * {
    @apply border-border ring-offset-background;
  }
  
  :focus-visible {
    @apply outline-ring-accent/60 outline-offset-0 outline-2;
  }
  
  body {
    @apply bg-background text-foreground;
  }
}`

  for (const baseColor of ['slate', 'gray', 'zinc', 'neutral', 'stone']) {
    const base: Record<string, any> = {
      inlineColors: {},
      cssVars: {},
    }
    for (const [mode, values] of Object.entries(colorMapping)) {
      base['inlineColors'][mode] = {}
      base['cssVars'][mode] = {}
      for (const [key, value] of Object.entries(values)) {
        if (typeof value === 'string') {
          // Chart colors do not have a 1-to-1 mapping with tailwind colors.
          if (key.startsWith('chart-') || value.match(/^\d{1,3}\s+\d{1,3}(?:\.\d+)?%\s+\d{1,3}(?:\.\d+)?%$/)) {
            base['cssVars'][mode][key] = value
            continue
          }

          const resolvedColor = value.replace(/{{base}}-/g, `${baseColor}-`)
          base['inlineColors'][mode][key] = resolvedColor

          const [resolvedBase, scale] = resolvedColor.split('-')
          const color = scale
            ? colorsData[resolvedBase].find((item: any) => item.scale === parseInt(scale))
            : colorsData[resolvedBase]
          if (color) {
            base['cssVars'][mode][key] = color.hslChannel
          }
        }
      }
    }

    // Build css vars.
    base['inlineColorsTemplate'] = template(BASE_STYLES)({})
    base['cssVarsTemplate'] = template(BASE_STYLES_WITH_VARIABLES)({
      colors: base['cssVars'],
    })

    await fs.writeFile(
      path.join(REGISTRY_PATH, `colors/${baseColor}.json`),
      JSON.stringify(base, null, 2),
      'utf8',
    )

    // ----------------------------------------------------------------------------
    // Build registry/themes.css
    // ----------------------------------------------------------------------------
    const THEME_STYLES_WITH_VARIABLES = `
.theme-<%- theme %> {
  --background: <%- colors.light['background'] %>;
  --foreground: <%- colors.light['foreground'] %>;

  --muted: <%- colors.light['muted'] %>;
  --muted-fg: <%- colors.light['muted-fg'] %>;

  --popover: <%- colors.light['popover'] %>;
  --popover-fg: <%- colors.light['popover-fg'] %>;

  --card: <%- colors.light['card'] %>;
  --card-fg: <%- colors.light['card-fg'] %>;

  --border: <%- colors.light['border'] %>;
  --input: <%- colors.light['input'] %>;

  --primary: <%- colors.light['primary'] %>;
  --primary-fg: <%- colors.light['primary-fg'] %>;

  --secondary: <%- colors.light['secondary'] %>;
  --secondary-fg: <%- colors.light['secondary-fg'] %>;

  --accent: <%- colors.light['accent'] %>;
  --accent-fg: <%- colors.light['accent-fg'] %>;

  --destructive: <%- colors.light['destructive'] %>;
  --destructive-fg: <%- colors.light['destructive-fg'] %>;

  --ring: <%- colors.light['ring'] %>;

  --radius: <%- colors.light['radius'] %>;
}

.dark .theme-<%- theme %> {
  --background: <%- colors.dark['background'] %>;
  --foreground: <%- colors.dark['foreground'] %>;

  --muted: <%- colors.dark['muted'] %>;
  --muted-fg: <%- colors.dark['muted-fg'] %>;

  --popover: <%- colors.dark['popover'] %>;
  --popover-fg: <%- colors.dark['popover-fg'] %>;

  --card: <%- colors.dark['card'] %>;
  --card-fg: <%- colors.dark['card-fg'] %>;

  --border: <%- colors.dark['border'] %>;
  --input: <%- colors.dark['input'] %>;

  --primary: <%- colors.dark['primary'] %>;
  --primary-fg: <%- colors.dark['primary-fg'] %>;

  --secondary: <%- colors.dark['secondary'] %>;
  --secondary-fg: <%- colors.dark['secondary-fg'] %>;

  --accent: <%- colors.dark['accent'] %>;
  --accent-fg: <%- colors.dark['accent-fg'] %>;

  --destructive: <%- colors.dark['destructive'] %>;
  --destructive-fg: <%- colors.dark['destructive-fg'] %>;

  --ring: <%- colors.dark['ring'] %>;
}`

    const themeCSS = []
    for (const theme of baseColors) {
      themeCSS.push(
        // @ts-ignore
        template(THEME_STYLES_WITH_VARIABLES)({
          colors: theme.cssVars,
          theme: theme.name,
        }),
      )
    }

    await fs.writeFile(path.join(REGISTRY_PATH, `themes.css`), themeCSS.join('\n'), 'utf8')

    // ----------------------------------------------------------------------------
    // Build registry/themes/[theme].json
    // ----------------------------------------------------------------------------
    rimraf.sync(path.join(REGISTRY_PATH, 'themes'))
    for (const baseColor of ['slate', 'gray', 'zinc', 'neutral', 'stone']) {
      const payload: Record<string, any> = {
        name: baseColor,
        label: baseColor.charAt(0).toUpperCase() + baseColor.slice(1),
        cssVars: {},
      }
      for (const [mode, values] of Object.entries(colorMapping)) {
        payload.cssVars[mode] = {}
        for (const [key, value] of Object.entries(values)) {
          if (typeof value === 'string') {
            const resolvedColor = value.replace(/{{base}}-/g, `${baseColor}-`)
            payload.cssVars[mode][key] = resolvedColor

            const [resolvedBase, scale] = resolvedColor.split('-')
            const color = scale
              ? colorsData[resolvedBase].find((item: any) => item.scale === parseInt(scale))
              : colorsData[resolvedBase]
            if (color) {
              payload['cssVars'][mode][key] = color.hslChannel
            }
          }
        }
      }

      const targetPath = path.join(REGISTRY_PATH, 'themes')

      // Create directory if it doesn't exist.
      if (!existsSync(targetPath)) {
        await fs.mkdir(targetPath, { recursive: true })
      }

      await fs.writeFile(
        path.join(targetPath, `${payload.name}.json`),
        JSON.stringify(payload, null, 2),
        'utf8',
      )
    }
  }
}

try {
  const result = registrySchema.safeParse(registry)

  if (!result.success) {
    console.error(result.error)
    process.exit(1)
  }

  await buildRegistry(result.data)
  await buildStyles(result.data)
  await buildStylesIndex()
  await buildThemes()

  console.log('âœ… Done!')
} catch (error) {
  console.error(error)
  process.exit(1)
}
